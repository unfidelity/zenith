//Deobfuscated with https://github.com/SimplyProgrammer/Minecraft-Deobfuscator3000 using mappings "C:\Users\Aestheticall\Documents\decomp\1.12 stable mappings"!

/*
 * Decompiled with CFR 0.152.
 */
package me.gopro336.zenith.feature.toggleable.exploit;

import java.util.ArrayList;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import me.gopro336.zenith.event.EventStageable;
import me.gopro336.zenith.event.network.PacketReceiveEvent;
import me.gopro336.zenith.event.network.PacketSendEvent;
import me.gopro336.zenith.event.player.MoveEvent;
import me.gopro336.zenith.event.player.UpdateWalkingPlayerEvent;
import me.gopro336.zenith.feature.AnnotationHelper;
import me.gopro336.zenith.feature.Category;
import me.gopro336.zenith.feature.Feature;
import me.gopro336.zenith.property.NumberProperty;
import me.gopro336.zenith.property.Property;
import net.minecraft.client.gui.GuiDownloadTerrain;
import net.minecraft.entity.Entity;
import net.minecraft.network.Packet;
import net.minecraft.network.play.client.CPacketConfirmTeleport;
import net.minecraft.network.play.client.CPacketPlayer;
import net.minecraft.network.play.server.SPacketPlayerPosLook;
import net.minecraft.util.math.BlockPos;
import team.stiff.pomelo.impl.annotated.handler.annotation.Listener;

@AnnotationHelper(name="PacketFly", description="Allows you to fly using packets", category=Category.MOVEMENT)
public class PacketFly
extends Feature {
    public NumberProperty<Integer> yDistance = new NumberProperty<Integer>((Feature)this, "Distance", "", 256, Integer.valueOf(1000), 10000);
    public Property<Enum> mode = new Property<modes>(this, "Mode", "", modes.Factor);
    public Property<Enum> phase = new Property<phaseModes>(this, "Phase", "", phaseModes.Full);
    public NumberProperty<Double> factor = new NumberProperty<Double>((Feature)this, "Speed", "", 0.0, Double.valueOf(1.0), 10.0);
    public Property<Boolean> antikick = new Property<Boolean>(this, "AntiKick", "", true);
    private int teleportId;
    private int otherids;
    private Map<Integer, PacketData> packetDataMap = new ConcurrentHashMap<Integer, PacketData>();
    private ArrayList<CPacketPlayer> packets = new ArrayList();

    @Listener
    public void event(UpdateWalkingPlayerEvent.Pre event) {
        PacketFly.mc.player.motionZ = 0.0;
        PacketFly.mc.player.motionY = 0.0;
        PacketFly.mc.player.motionX = 0.0;
        if (!this.mode.getValue().toString().equalsIgnoreCase("Fast") && this.teleportId == 0) {
            this.move(0.0, 0.0, 0.0, false);
            return;
        }
        boolean collide = this.collideCheck();
        double n2 = 0.0;
        if (PacketFly.mc.gameSettings.keyBindJump.isKeyDown() && collide) {
            n2 = this.antikick.getValue().booleanValue() && !collide ? (this.idCheck(this.mode.getValue().toString().equalsIgnoreCase("Fast") ? 10 : 20) ? 1.748524532E-314 : 1.6636447E-314) : 1.6636447E-314;
        } else if (PacketFly.mc.gameSettings.keyBindSneak.isKeyDown()) {
            n2 = 1.6636447E-314;
        } else {
            double d = collide ? 0.0 : (this.idCheck(4) ? (this.antikick.getValue().booleanValue() ? 5.941588215E-315 : 0.0) : (n2 = 0.0));
        }
        if (this.phase.getValue().toString().equalsIgnoreCase("Off") && collide && n2 != 0.0) {
            n2 = 0.0;
        }
        double[] speed = this.directionSpeed(this.phase.getValue().toString().equalsIgnoreCase("Off") && collide ? 1.6636447E-314 : 8.48798317E-316);
        int i = 0;
        while (true) {
            double d = i;
            double d2 = this.mode.getValue().toString().equalsIgnoreCase("Factor") ? (Double)this.factor.getValue() : 1.0;
            if (!(d <= d2)) break;
            PacketFly.mc.player.motionX = speed[0];
            PacketFly.mc.player.motionY = n2;
            PacketFly.mc.player.motionZ = speed[1];
            this.move(PacketFly.mc.player.motionX, PacketFly.mc.player.motionY, PacketFly.mc.player.motionZ, !this.mode.getValue().toString().equalsIgnoreCase("Fact0r"));
            ++i;
        }
    }

    @Listener
    public void onMove(MoveEvent event) {
        event.setX(PacketFly.mc.player.motionX);
        event.setY(PacketFly.mc.player.motionY);
        event.setZ(PacketFly.mc.player.motionZ);
        if (!this.phase.getValue().toString().equalsIgnoreCase("Full") && (this.phase.getValue().toString().equalsIgnoreCase("Semi") || this.collideCheck()) && this.teleportId != 0) {
            PacketFly.mc.player.noClip = true;
        }
    }

    @Listener
    public void eventPacketSent(PacketSendEvent event) {
        if (event.getStage() != EventStageable.EventStage.PRE) {
            return;
        }
        if (event.getPacket() instanceof CPacketPlayer) {
            CPacketPlayer packet = (CPacketPlayer)event.getPacket();
            if (this.packets.contains(packet)) {
                this.packets.remove(packet);
                return;
            }
            event.setCanceled(true);
        }
    }

    @Listener
    public void eventPacketReceived(PacketReceiveEvent event) {
        if (event.getStage() != EventStageable.EventStage.PRE) {
            return;
        }
        if (event.getPacket() instanceof SPacketPlayerPosLook) {
            SPacketPlayerPosLook packet = (SPacketPlayerPosLook)event.getPacket();
            if (PacketFly.mc.player.isEntityAlive() && PacketFly.mc.world.isBlockLoaded(new BlockPos(PacketFly.mc.player.posX, PacketFly.mc.player.posY, PacketFly.mc.player.posZ), false) && !(PacketFly.mc.currentScreen instanceof GuiDownloadTerrain)) {
                PacketData data = this.packetDataMap.get(packet.getTeleportId());
                if (!this.mode.getValue().toString().equalsIgnoreCase("Fast") && data != null && data.getX() == packet.getX() && data.getY() == packet.getY() && data.getZ() == packet.getZ()) {
                    event.setCanceled(true);
                    return;
                }
                this.teleportId = packet.getTeleportId();
            }
        }
    }

    @Override
    public void onDisable() {
        this.teleportId = 0;
        this.otherids = 0;
        this.packets.clear();
        this.packetDataMap.clear();
    }

    private boolean collideCheck() {
        return !PacketFly.mc.world.getCollisionBoxes((Entity)PacketFly.mc.player, PacketFly.mc.player.getEntityBoundingBox().expand(0.0, 0.0, 0.0)).isEmpty();
    }

    private boolean idCheck(int id) {
        if (++this.otherids >= id) {
            this.otherids = 0;
            return true;
        }
        return false;
    }

    public void move(double x, double y, double z, boolean teleportPacket) {
        CPacketPlayer.Position pos = new CPacketPlayer.Position(PacketFly.mc.player.posX + x, PacketFly.mc.player.posY + y, PacketFly.mc.player.posZ + z, PacketFly.mc.player.onGround);
        this.packets.add((CPacketPlayer)pos);
        PacketFly.mc.player.connection.sendPacket((Packet)pos);
        CPacketPlayer.Position bounds = new CPacketPlayer.Position(PacketFly.mc.player.posX + x, PacketFly.mc.player.posY + y - 1337.42, PacketFly.mc.player.posZ + z, PacketFly.mc.player.onGround);
        this.packets.add((CPacketPlayer)bounds);
        PacketFly.mc.player.connection.sendPacket((Packet)bounds);
        if (teleportPacket) {
            ++this.teleportId;
            PacketFly.mc.player.connection.sendPacket((Packet)new CPacketConfirmTeleport(this.teleportId));
            this.packetDataMap.put(this.teleportId, new PacketData(PacketFly.mc.player.posX + x, PacketFly.mc.player.posY + y, PacketFly.mc.player.posZ, System.currentTimeMillis()));
        }
    }

    public double[] directionSpeed(double speed) {
        float forward = PacketFly.mc.player.movementInput.moveForward;
        float side = PacketFly.mc.player.movementInput.moveStrafe;
        float yaw = PacketFly.mc.player.rotationYaw;
        if (forward != 0.0f) {
            if (side > 0.0f) {
                yaw += (float)(forward > 0.0f ? -45 : 45);
            } else if (side < 0.0f) {
                yaw += (float)(forward > 0.0f ? 45 : -45);
            }
            side = 0.0f;
            if (forward > 0.0f) {
                forward = 1.0f;
            } else if (forward < 0.0f) {
                forward = -1.0f;
            }
        }
        double posX = (double)forward * speed * Math.cos(Math.toRadians(yaw + 90.0f)) + (double)side * speed * Math.sin(Math.toRadians(yaw + 90.0f));
        double posZ = (double)forward * speed * Math.sin(Math.toRadians(yaw + 90.0f)) - (double)side * speed * Math.cos(Math.toRadians(yaw + 90.0f));
        return new double[]{posX, posZ};
    }

    public static class PacketData {
        private double x;
        private double y;
        private double z;
        private long time;

        public PacketData(double x, double y, double z, long time) {
            this.x = x;
            this.y = y;
            this.z = z;
            this.time = time;
        }

        public double getX() {
            return this.x;
        }

        public void setX(double x) {
            this.x = x;
        }

        public double getY() {
            return this.y;
        }

        public void setY(double y) {
            this.y = y;
        }

        public double getZ() {
            return this.z;
        }

        public void setZ(double z) {
            this.z = z;
        }

        public long getTime() {
            return this.time;
        }

        public void setTime(long time) {
            this.time = time;
        }
    }

    private static enum phaseModes {
        Full,
        Off,
        Semi;

    }

    private static enum modes {
        Factor,
        Setback,
        Fast;

    }
}

